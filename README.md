# Flight Booking Simulator

A demo flight booking simulator (React + Tailwind frontend, Flask + SQLite backend) for experimenting with search, dynamic pricing, seat holds, booking flows and queued email delivery.

## Repository

Files of interest:
- `backend/` — Flask API, database scripts, email queue worker.
- `frontend/` — Vite + React + Tailwind UI (dev server on port 5173/5174).
- `schema.sql`, `backend/sample_data.csv` — DB schema and sample data used by `backend/db_init.py`.

## Quick start (Windows)

1. Backend setup

```powershell
cd D:\Flight-Booking-Simulator\backend
python -m venv .venv
.\.venv\Scripts\activate
pip install -r requirements.txt
# Initialize the database from the CSV (this creates flights.db)
python db_init.py
# Start the backend (default: http://127.0.0.1:5000)
python app.py
```

2. Frontend setup

```powershell
cd D:\Flight-Booking-Simulator\frontend
npm install
npm run dev
# Open the Local URL printed by Vite (e.g. http://localhost:5174)
```

3. Run quick auth tests (optional)

```powershell
python ..\backend\test_auth.py
```

## Environment variables (optional)

Create a `.env` file in `backend/` or set environment vars to customize behavior:
- `SECRET_KEY` — Flask session secret
- `FRONTEND_ORIGIN` — allowed origin used by CORS fallback
- `SMTP_HOST`, `SMTP_PORT`, `SMTP_USER`, `SMTP_PASS` — configure these to enable real email sending (otherwise emails are queued but skipped)

## Notes
- The `image/` folder is excluded from the repository via `.gitignore` per your request.
- `backend/db_init.py` reads `backend/sample_data.csv` to populate `flights.db` — re-run it after changing the CSV.
- If you see a `no such table: flights` error, re-run `python backend/db_init.py` to recreate the database.

## Deploy with Docker

You can run the whole app with Docker and docker-compose.

Build and start services:

```bash
docker-compose build
docker-compose up --detach
```

- Backend will be available at `http://localhost:5000`.
- Frontend static site served on port `5173` (proxied to nginx port 80 inside the container).

To view logs:

```bash
docker-compose logs -f backend
docker-compose logs -f frontend
```

To stop and remove containers:

```bash
docker-compose down
```

## Deploy backend on Render

Render can host the Flask backend. Two options:

- Quick (use SQLite file): create a new **Web Service** on Render connected to this GitHub repo. Set:
	- Environment: `Python 3`
	- Build Command: `pip install -r backend/requirements.txt`
	- Start Command: `gunicorn -w 4 backend.app:app -b 0.0.0.0:$PORT`
	- Add env var `SECRET_KEY` and any SMTP settings (`SMTP_HOST`, `SMTP_PORT`, `SMTP_USER`, `SMTP_PASS`) if you want real emails.

	Note: Using SQLite inside Render is okay for demos, but the file is stored on the instance and may not persist across deploys. For production use, switch to a managed database (Postgres) and update `backend/app.py` to use the `DATABASE_URL` environment variable.

- Docker (recommended if you want an identical environment): create a **Web Service** using the Docker option and point it at the repo; Render will use the `backend/Dockerfile` we added.

After creation, enable auto-deploys from the `main` branch so pushing updates triggers redeploys.

## Deploy frontend on Vercel

1. Go to https://vercel.com/new and select your GitHub repository `PreetiYadav99/Flight-Booking-Simulator`.
2. In project settings set:
	 - Framework Preset: `Other` or `Vite`
	 - Root Directory: `frontend`
	 - Build Command: `npm run build`
	 - Output Directory: `dist`
3. Add any env var your frontend needs (e.g., `VITE_API_URL=http://<your-backend-url>`).

We included `frontend/vercel.json` to help Vercel detect the build configuration automatically.

## Recommended production changes

- Use a managed Postgres database instead of SQLite for the backend and set `DATABASE_URL` on Render. Update `backend` code to use SQLAlchemy or parse `DATABASE_URL`.
- Move SMTP credentials to Render environment variables and ensure TLS settings are configured.
- Add monitoring, backups, and proper secret management for production readiness.


## Contributing / Next steps
- If you'd like, I can add a short `README` section with deployment steps (Docker / WSGI) or create GitHub Actions to run basic tests.

---
Generated by the project maintainer automation.
